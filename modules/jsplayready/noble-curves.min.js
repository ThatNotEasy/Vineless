var Te=Object.defineProperty;var Le=(e,n)=>{for(var t in n)Te(e,t,{get:n[t],enumerable:!0})};function re(e){if(!Number.isSafeInteger(e)||e<0)throw new Error("positive integer expected, got "+e)}function qe(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function wt(e,...n){if(!qe(e))throw new Error("Uint8Array expected");if(n.length>0&&!n.includes(e.length))throw new Error("Uint8Array expected of length "+n+", got length="+e.length)}function oe(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");re(e.outputLen),re(e.blockLen)}function pt(e,n=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(n&&e.finished)throw new Error("Hash#digest() has already been called")}function ie(e,n){wt(e);let t=n.outputLen;if(e.length<t)throw new Error("digestInto() expects output buffer of length at least "+t)}var st=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;function At(e){return new DataView(e.buffer,e.byteOffset,e.byteLength)}function K(e,n){return e<<32-n|e>>>n}function Ne(e){if(typeof e!="string")throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array(new TextEncoder().encode(e))}function Bt(e){return typeof e=="string"&&(e=Ne(e)),wt(e),e}function se(...e){let n=0;for(let r=0;r<e.length;r++){let o=e[r];wt(o),n+=o.length}let t=new Uint8Array(n);for(let r=0,o=0;r<e.length;r++){let i=e[r];t.set(i,o),o+=i.length}return t}var mt=class{clone(){return this._cloneInto()}};function ce(e){let n=r=>e().update(Bt(r)).digest(),t=e();return n.outputLen=t.outputLen,n.blockLen=t.blockLen,n.create=()=>e(),n}function fe(e=32){if(st&&typeof st.getRandomValues=="function")return st.getRandomValues(new Uint8Array(e));if(st&&typeof st.randomBytes=="function")return st.randomBytes(e);throw new Error("crypto.getRandomValues must be defined")}function Ue(e,n,t,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(n,t,r);let o=BigInt(32),i=BigInt(4294967295),c=Number(t>>o&i),f=Number(t&i),s=r?4:0,a=r?0:4;e.setUint32(n+s,c,r),e.setUint32(n+a,f,r)}function ue(e,n,t){return e&n^~e&t}function ae(e,n,t){return e&n^e&t^n&t}var Ot=class extends mt{constructor(n,t,r,o){super(),this.blockLen=n,this.outputLen=t,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=At(this.buffer)}update(n){pt(this);let{view:t,buffer:r,blockLen:o}=this;n=Bt(n);let i=n.length;for(let c=0;c<i;){let f=Math.min(o-this.pos,i-c);if(f===o){let s=At(n);for(;o<=i-c;c+=o)this.process(s,c);continue}r.set(n.subarray(c,c+f),this.pos),this.pos+=f,c+=f,this.pos===o&&(this.process(t,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){pt(this),ie(n,this),this.finished=!0;let{buffer:t,view:r,blockLen:o,isLE:i}=this,{pos:c}=this;t[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>o-c&&(this.process(r,0),c=0);for(let h=c;h<o;h++)t[h]=0;Ue(r,o-8,BigInt(this.length*8),i),this.process(r,0);let f=At(n),s=this.outputLen;if(s%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let a=s/4,E=this.get();if(a>E.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<a;h++)f.setUint32(4*h,E[h],i)}digest(){let{buffer:n,outputLen:t}=this;this.digestInto(n);let r=n.slice(0,t);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());let{blockLen:t,buffer:r,length:o,finished:i,destroyed:c,pos:f}=this;return n.length=o,n.pos=f,n.finished=i,n.destroyed=c,o%t&&n.buffer.set(r),n}};var Re=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),$=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),F=new Uint32Array(64),Zt=class extends Ot{constructor(){super(64,32,8,!1),this.A=$[0]|0,this.B=$[1]|0,this.C=$[2]|0,this.D=$[3]|0,this.E=$[4]|0,this.F=$[5]|0,this.G=$[6]|0,this.H=$[7]|0}get(){let{A:n,B:t,C:r,D:o,E:i,F:c,G:f,H:s}=this;return[n,t,r,o,i,c,f,s]}set(n,t,r,o,i,c,f,s){this.A=n|0,this.B=t|0,this.C=r|0,this.D=o|0,this.E=i|0,this.F=c|0,this.G=f|0,this.H=s|0}process(n,t){for(let h=0;h<16;h++,t+=4)F[h]=n.getUint32(t,!1);for(let h=16;h<64;h++){let d=F[h-15],x=F[h-2],L=K(d,7)^K(d,18)^d>>>3,m=K(x,17)^K(x,19)^x>>>10;F[h]=m+F[h-7]+L+F[h-16]|0}let{A:r,B:o,C:i,D:c,E:f,F:s,G:a,H:E}=this;for(let h=0;h<64;h++){let d=K(f,6)^K(f,11)^K(f,25),x=E+d+ue(f,s,a)+Re[h]+F[h]|0,m=(K(r,2)^K(r,13)^K(r,22))+ae(r,o,i)|0;E=a,a=s,s=f,f=c+x|0,c=i,i=o,o=r,r=x+m|0}r=r+this.A|0,o=o+this.B|0,i=i+this.C|0,c=c+this.D|0,f=f+this.E|0,s=s+this.F|0,a=a+this.G|0,E=E+this.H|0,this.set(r,o,i,c,f,s,a,E)}roundClean(){F.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};var le=ce(()=>new Zt);var It=class extends mt{constructor(n,t){super(),this.finished=!1,this.destroyed=!1,oe(n);let r=Bt(t);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let o=this.blockLen,i=new Uint8Array(o);i.set(r.length>o?n.create().update(r).digest():r);for(let c=0;c<i.length;c++)i[c]^=54;this.iHash.update(i),this.oHash=n.create();for(let c=0;c<i.length;c++)i[c]^=106;this.oHash.update(i),i.fill(0)}update(n){return pt(this),this.iHash.update(n),this}digestInto(n){pt(this),wt(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){let n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));let{oHash:t,iHash:r,finished:o,destroyed:i,blockLen:c,outputLen:f}=this;return n=n,n.finished=o,n.destroyed=i,n.blockLen=c,n.outputLen=f,n.oHash=t._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},jt=(e,n,t)=>new It(e,n).update(t).digest();jt.create=(e,n)=>new It(e,n);var Rt={};Le(Rt,{aInRange:()=>nt,abool:()=>ct,abytes:()=>xt,bitGet:()=>Ze,bitLen:()=>Yt,bitMask:()=>St,bitSet:()=>je,bytesToHex:()=>ft,bytesToNumberBE:()=>P,bytesToNumberLE:()=>qt,concatBytes:()=>yt,createHmacDrbg:()=>Kt,ensureBytes:()=>M,equalBytes:()=>ke,hexToBytes:()=>at,hexToNumber:()=>Dt,inRange:()=>vt,isBytes:()=>tt,memoized:()=>Ut,notImplemented:()=>Me,numberToBytesBE:()=>et,numberToBytesLE:()=>Nt,numberToHexUnpadded:()=>ut,numberToVarBytesBE:()=>Ce,utf8ToBytes:()=>Ve,validateObject:()=>rt});var Tt=BigInt(0),Lt=BigInt(1),He=BigInt(2);function tt(e){return e instanceof Uint8Array||ArrayBuffer.isView(e)&&e.constructor.name==="Uint8Array"}function xt(e){if(!tt(e))throw new Error("Uint8Array expected")}function ct(e,n){if(typeof n!="boolean")throw new Error(e+" boolean expected, got "+n)}var _e=Array.from({length:256},(e,n)=>n.toString(16).padStart(2,"0"));function ft(e){xt(e);let n="";for(let t=0;t<e.length;t++)n+=_e[e[t]];return n}function ut(e){let n=e.toString(16);return n.length&1?"0"+n:n}function Dt(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return e===""?Tt:BigInt("0x"+e)}var G={_0:48,_9:57,A:65,F:70,a:97,f:102};function de(e){if(e>=G._0&&e<=G._9)return e-G._0;if(e>=G.A&&e<=G.F)return e-(G.A-10);if(e>=G.a&&e<=G.f)return e-(G.a-10)}function at(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);let n=e.length,t=n/2;if(n%2)throw new Error("hex string expected, got unpadded hex of length "+n);let r=new Uint8Array(t);for(let o=0,i=0;o<t;o++,i+=2){let c=de(e.charCodeAt(i)),f=de(e.charCodeAt(i+1));if(c===void 0||f===void 0){let s=e[i]+e[i+1];throw new Error('hex string expected, got non-hex character "'+s+'" at index '+i)}r[o]=c*16+f}return r}function P(e){return Dt(ft(e))}function qt(e){return xt(e),Dt(ft(Uint8Array.from(e).reverse()))}function et(e,n){return at(e.toString(16).padStart(n*2,"0"))}function Nt(e,n){return et(e,n).reverse()}function Ce(e){return at(ut(e))}function M(e,n,t){let r;if(typeof n=="string")try{r=at(n)}catch(i){throw new Error(e+" must be hex string or Uint8Array, cause: "+i)}else if(tt(n))r=Uint8Array.from(n);else throw new Error(e+" must be hex string or Uint8Array");let o=r.length;if(typeof t=="number"&&o!==t)throw new Error(e+" of length "+t+" expected, got "+o);return r}function yt(...e){let n=0;for(let r=0;r<e.length;r++){let o=e[r];xt(o),n+=o.length}let t=new Uint8Array(n);for(let r=0,o=0;r<e.length;r++){let i=e[r];t.set(i,o),o+=i.length}return t}function ke(e,n){if(e.length!==n.length)return!1;let t=0;for(let r=0;r<e.length;r++)t|=e[r]^n[r];return t===0}function Ve(e){if(typeof e!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(e))}var zt=e=>typeof e=="bigint"&&Tt<=e;function vt(e,n,t){return zt(e)&&zt(n)&&zt(t)&&n<=e&&e<t}function nt(e,n,t,r){if(!vt(n,t,r))throw new Error("expected valid "+e+": "+t+" <= n < "+r+", got "+n)}function Yt(e){let n;for(n=0;e>Tt;e>>=Lt,n+=1);return n}function Ze(e,n){return e>>BigInt(n)&Lt}function je(e,n,t){return e|(t?Lt:Tt)<<BigInt(n)}var St=e=>(He<<BigInt(e-1))-Lt,Mt=e=>new Uint8Array(e),he=e=>Uint8Array.from(e);function Kt(e,n,t){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof t!="function")throw new Error("hmacFn must be a function");let r=Mt(e),o=Mt(e),i=0,c=()=>{r.fill(1),o.fill(0),i=0},f=(...h)=>t(o,r,...h),s=(h=Mt())=>{o=f(he([0]),h),r=f(),h.length!==0&&(o=f(he([1]),h),r=f())},a=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let h=0,d=[];for(;h<n;){r=f();let x=r.slice();d.push(x),h+=r.length}return yt(...d)};return(h,d)=>{c(),s(h);let x;for(;!(x=d(a()));)s();return c(),x}}var ze={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||tt(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,n)=>n.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function rt(e,n,t={}){let r=(o,i,c)=>{let f=ze[i];if(typeof f!="function")throw new Error("invalid validator function");let s=e[o];if(!(c&&s===void 0)&&!f(s,e))throw new Error("param "+String(o)+" is invalid. Expected "+i+", got "+s)};for(let[o,i]of Object.entries(n))r(o,i,!1);for(let[o,i]of Object.entries(t))r(o,i,!0);return e}var Me=()=>{throw new Error("not implemented")};function Ut(e){let n=new WeakMap;return(t,...r)=>{let o=n.get(t);if(o!==void 0)return o;let i=e(t,...r);return n.set(t,i),i}}var _=BigInt(0),R=BigInt(1),lt=BigInt(2),De=BigInt(3),Wt=BigInt(4),ge=BigInt(5),we=BigInt(8),Ye=BigInt(9),Ke=BigInt(16);function D(e,n){let t=e%n;return t>=_?t:n+t}function We(e,n,t){if(n<_)throw new Error("invalid exponent, negatives unsupported");if(t<=_)throw new Error("invalid modulus");if(t===R)return _;let r=R;for(;n>_;)n&R&&(r=r*e%t),e=e*e%t,n>>=R;return r}function Ht(e,n){if(e===_)throw new Error("invert: expected non-zero number");if(n<=_)throw new Error("invert: expected positive modulus, got "+n);let t=D(e,n),r=n,o=_,i=R,c=R,f=_;for(;t!==_;){let a=r/t,E=r%t,h=o-c*a,d=i-f*a;r=t,t=E,o=c,i=f,c=h,f=d}if(r!==R)throw new Error("invert: does not exist");return D(o,n)}function Ge(e){let n=(e-R)/lt,t,r,o;for(t=e-R,r=0;t%lt===_;t/=lt,r++);for(o=lt;o<e&&We(o,n,e)!==e-R;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(r===1){let c=(e+R)/Wt;return function(s,a){let E=s.pow(a,c);if(!s.eql(s.sqr(E),a))throw new Error("Cannot find square root");return E}}let i=(t+R)/lt;return function(f,s){if(f.pow(s,n)===f.neg(f.ONE))throw new Error("Cannot find square root");let a=r,E=f.pow(f.mul(f.ONE,o),t),h=f.pow(s,i),d=f.pow(s,t);for(;!f.eql(d,f.ONE);){if(f.eql(d,f.ZERO))return f.ZERO;let x=1;for(let m=f.sqr(d);x<a&&!f.eql(m,f.ONE);x++)m=f.sqr(m);let L=f.pow(E,R<<BigInt(a-x-1));E=f.sqr(L),h=f.mul(h,L),d=f.mul(d,E),a=x}return h}}function Pe(e){if(e%Wt===De){let n=(e+R)/Wt;return function(r,o){let i=r.pow(o,n);if(!r.eql(r.sqr(i),o))throw new Error("Cannot find square root");return i}}if(e%we===ge){let n=(e-ge)/we;return function(r,o){let i=r.mul(o,lt),c=r.pow(i,n),f=r.mul(o,c),s=r.mul(r.mul(f,lt),c),a=r.mul(f,r.sub(s,r.ONE));if(!r.eql(r.sqr(a),o))throw new Error("Cannot find square root");return a}}return e%Ke,Ge(e)}var Xe=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Gt(e){let n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=Xe.reduce((r,o)=>(r[o]="function",r),n);return rt(e,t)}function Qe(e,n,t){if(t<_)throw new Error("invalid exponent, negatives unsupported");if(t===_)return e.ONE;if(t===R)return n;let r=e.ONE,o=n;for(;t>_;)t&R&&(r=e.mul(r,o)),o=e.sqr(o),t>>=R;return r}function Je(e,n){let t=new Array(n.length),r=n.reduce((i,c,f)=>e.is0(c)?i:(t[f]=i,e.mul(i,c)),e.ONE),o=e.inv(r);return n.reduceRight((i,c,f)=>e.is0(c)?i:(t[f]=e.mul(i,t[f]),e.mul(i,c)),o),t}function Pt(e,n){let t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function _t(e,n,t=!1,r={}){if(e<=_)throw new Error("invalid field: expected ORDER > 0, got "+e);let{nBitLength:o,nByteLength:i}=Pt(e,n);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c,f=Object.freeze({ORDER:e,isLE:t,BITS:o,BYTES:i,MASK:St(o),ZERO:_,ONE:R,create:s=>D(s,e),isValid:s=>{if(typeof s!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof s);return _<=s&&s<e},is0:s=>s===_,isOdd:s=>(s&R)===R,neg:s=>D(-s,e),eql:(s,a)=>s===a,sqr:s=>D(s*s,e),add:(s,a)=>D(s+a,e),sub:(s,a)=>D(s-a,e),mul:(s,a)=>D(s*a,e),pow:(s,a)=>Qe(f,s,a),div:(s,a)=>D(s*Ht(a,e),e),sqrN:s=>s*s,addN:(s,a)=>s+a,subN:(s,a)=>s-a,mulN:(s,a)=>s*a,inv:s=>Ht(s,e),sqrt:r.sqrt||(s=>(c||(c=Pe(e)),c(f,s))),invertBatch:s=>Je(f,s),cmov:(s,a,E)=>E?a:s,toBytes:s=>t?Nt(s,i):et(s,i),fromBytes:s=>{if(s.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+s.length);return t?qt(s):P(s)}});return Object.freeze(f)}function pe(e){if(typeof e!="bigint")throw new Error("field order must be bigint");let n=e.toString(2).length;return Math.ceil(n/8)}function Xt(e){let n=pe(e);return n+Math.ceil(n/2)}function me(e,n,t=!1){let r=e.length,o=pe(n),i=Xt(n);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);let c=t?qt(e):P(e),f=D(c,n-R)+R;return t?Nt(f,o):et(f,o)}var xe=BigInt(0),Ct=BigInt(1);function Qt(e,n){let t=n.negate();return e?t:n}function ye(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function Jt(e,n){ye(e,n);let t=Math.ceil(n/e)+1,r=2**(e-1);return{windows:t,windowSize:r}}function $e(e,n){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,r)=>{if(!(t instanceof n))throw new Error("invalid point at index "+r)})}function Fe(e,n){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,r)=>{if(!n.isValid(t))throw new Error("invalid scalar at index "+r)})}var $t=new WeakMap,be=new WeakMap;function Ft(e){return be.get(e)||1}function Ee(e,n){return{constTimeNegate:Qt,hasPrecomputes(t){return Ft(t)!==1},unsafeLadder(t,r,o=e.ZERO){let i=t;for(;r>xe;)r&Ct&&(o=o.add(i)),i=i.double(),r>>=Ct;return o},precomputeWindow(t,r){let{windows:o,windowSize:i}=Jt(r,n),c=[],f=t,s=f;for(let a=0;a<o;a++){s=f,c.push(s);for(let E=1;E<i;E++)s=s.add(f),c.push(s);f=s.double()}return c},wNAF(t,r,o){let{windows:i,windowSize:c}=Jt(t,n),f=e.ZERO,s=e.BASE,a=BigInt(2**t-1),E=2**t,h=BigInt(t);for(let d=0;d<i;d++){let x=d*c,L=Number(o&a);o>>=h,L>c&&(L-=E,o+=Ct);let m=x,u=x+Math.abs(L)-1,g=d%2!==0,y=L<0;L===0?s=s.add(Qt(g,r[m])):f=f.add(Qt(y,r[u]))}return{p:f,f:s}},wNAFUnsafe(t,r,o,i=e.ZERO){let{windows:c,windowSize:f}=Jt(t,n),s=BigInt(2**t-1),a=2**t,E=BigInt(t);for(let h=0;h<c;h++){let d=h*f;if(o===xe)break;let x=Number(o&s);if(o>>=E,x>f&&(x-=a,o+=Ct),x===0)continue;let L=r[d+Math.abs(x)-1];x<0&&(L=L.negate()),i=i.add(L)}return i},getPrecomputes(t,r,o){let i=$t.get(r);return i||(i=this.precomputeWindow(r,t),t!==1&&$t.set(r,o(i))),i},wNAFCached(t,r,o){let i=Ft(t);return this.wNAF(i,this.getPrecomputes(i,t,o),r)},wNAFCachedUnsafe(t,r,o,i){let c=Ft(t);return c===1?this.unsafeLadder(t,r,i):this.wNAFUnsafe(c,this.getPrecomputes(c,t,o),r,i)},setWindowSize(t,r){ye(r,n),be.set(t,r),$t.delete(t)}}}function Be(e,n,t,r){if($e(t,e),Fe(r,n),t.length!==r.length)throw new Error("arrays of points and scalars must have equal length");let o=e.ZERO,i=Yt(BigInt(t.length)),c=i>12?i-3:i>4?i-2:i?2:1,f=(1<<c)-1,s=new Array(f+1).fill(o),a=Math.floor((n.BITS-1)/c)*c,E=o;for(let h=a;h>=0;h-=c){s.fill(o);for(let x=0;x<r.length;x++){let L=r[x],m=Number(L>>BigInt(h)&BigInt(f));s[m]=s[m].add(t[x])}let d=o;for(let x=s.length-1,L=o;x>0;x--)L=L.add(s[x]),d=d.add(L);if(E=E.add(d),h!==0)for(let x=0;x<c;x++)E=E.double()}return E}function te(e){return Gt(e.Fp),rt(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Pt(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}function ve(e){e.lowS!==void 0&&ct("lowS",e.lowS),e.prehash!==void 0&&ct("prehash",e.prehash)}function tn(e){let n=te(e);rt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});let{endo:t,Fp:r,a:o}=n;if(t){if(!r.eql(o,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...n})}var{bytesToNumberBE:en,hexToBytes:nn}=Rt,ee=class extends Error{constructor(n=""){super(n)}},X={Err:ee,_tlv:{encode:(e,n)=>{let{Err:t}=X;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length&1)throw new t("tlv.encode: unpadded data");let r=n.length/2,o=ut(r);if(o.length/2&128)throw new t("tlv.encode: long form length too big");let i=r>127?ut(o.length/2|128):"";return ut(e)+i+o+n},decode(e,n){let{Err:t}=X,r=0;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length<2||n[r++]!==e)throw new t("tlv.decode: wrong tlv");let o=n[r++],i=!!(o&128),c=0;if(!i)c=o;else{let s=o&127;if(!s)throw new t("tlv.decode(long): indefinite length not supported");if(s>4)throw new t("tlv.decode(long): byte length is too big");let a=n.subarray(r,r+s);if(a.length!==s)throw new t("tlv.decode: length bytes not complete");if(a[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(let E of a)c=c<<8|E;if(r+=s,c<128)throw new t("tlv.decode(long): not minimal encoding")}let f=n.subarray(r,r+c);if(f.length!==c)throw new t("tlv.decode: wrong value length");return{v:f,l:n.subarray(r+c)}}},_int:{encode(e){let{Err:n}=X;if(e<Q)throw new n("integer: negative integers are not allowed");let t=ut(e);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return t},decode(e){let{Err:n}=X;if(e[0]&128)throw new n("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return en(e)}},toSig(e){let{Err:n,_int:t,_tlv:r}=X,o=typeof e=="string"?nn(e):e;xt(o);let{v:i,l:c}=r.decode(48,o);if(c.length)throw new n("invalid signature: left bytes after parsing");let{v:f,l:s}=r.decode(2,i),{v:a,l:E}=r.decode(2,s);if(E.length)throw new n("invalid signature: left bytes after parsing");return{r:t.decode(f),s:t.decode(a)}},hexFromSig(e){let{_tlv:n,_int:t}=X,r=n.encode(2,t.encode(e.r)),o=n.encode(2,t.encode(e.s)),i=r+o;return n.encode(48,i)}},Q=BigInt(0),C=BigInt(1),Rn=BigInt(2),Se=BigInt(3),Hn=BigInt(4);function rn(e){let n=tn(e),{Fp:t}=n,r=_t(n.n,n.nBitLength),o=n.toBytes||((m,u,g)=>{let y=u.toAffine();return yt(Uint8Array.from([4]),t.toBytes(y.x),t.toBytes(y.y))}),i=n.fromBytes||(m=>{let u=m.subarray(1),g=t.fromBytes(u.subarray(0,t.BYTES)),y=t.fromBytes(u.subarray(t.BYTES,2*t.BYTES));return{x:g,y}});function c(m){let{a:u,b:g}=n,y=t.sqr(m),v=t.mul(y,m);return t.add(t.add(v,t.mul(m,u)),g)}if(!t.eql(t.sqr(n.Gy),c(n.Gx)))throw new Error("bad generator point: equation left != right");function f(m){return vt(m,C,n.n)}function s(m){let{allowedPrivateKeyLengths:u,nByteLength:g,wrapPrivateKey:y,n:v}=n;if(u&&typeof m!="bigint"){if(tt(m)&&(m=ft(m)),typeof m!="string"||!u.includes(m.length))throw new Error("invalid private key");m=m.padStart(g*2,"0")}let O;try{O=typeof m=="bigint"?m:P(M("private key",m,g))}catch{throw new Error("invalid private key, expected hex or "+g+" bytes, got "+typeof m)}return y&&(O=D(O,v)),nt("private key",O,C,v),O}function a(m){if(!(m instanceof d))throw new Error("ProjectivePoint expected")}let E=Ut((m,u)=>{let{px:g,py:y,pz:v}=m;if(t.eql(v,t.ONE))return{x:g,y};let O=m.is0();u==null&&(u=O?t.ONE:t.inv(v));let N=t.mul(g,u),I=t.mul(y,u),b=t.mul(v,u);if(O)return{x:t.ZERO,y:t.ZERO};if(!t.eql(b,t.ONE))throw new Error("invZ was invalid");return{x:N,y:I}}),h=Ut(m=>{if(m.is0()){if(n.allowInfinityPoint&&!t.is0(m.py))return;throw new Error("bad point: ZERO")}let{x:u,y:g}=m.toAffine();if(!t.isValid(u)||!t.isValid(g))throw new Error("bad point: x or y not FE");let y=t.sqr(g),v=c(u);if(!t.eql(y,v))throw new Error("bad point: equation left != right");if(!m.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class d{constructor(u,g,y){if(this.px=u,this.py=g,this.pz=y,u==null||!t.isValid(u))throw new Error("x required");if(g==null||!t.isValid(g))throw new Error("y required");if(y==null||!t.isValid(y))throw new Error("z required");Object.freeze(this)}static fromAffine(u){let{x:g,y}=u||{};if(!u||!t.isValid(g)||!t.isValid(y))throw new Error("invalid affine point");if(u instanceof d)throw new Error("projective point not allowed");let v=O=>t.eql(O,t.ZERO);return v(g)&&v(y)?d.ZERO:new d(g,y,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){let g=t.invertBatch(u.map(y=>y.pz));return u.map((y,v)=>y.toAffine(g[v])).map(d.fromAffine)}static fromHex(u){let g=d.fromAffine(i(M("pointHex",u)));return g.assertValidity(),g}static fromPrivateKey(u){return d.BASE.multiply(s(u))}static msm(u,g){return Be(d,r,u,g)}_setWindowSize(u){L.setWindowSize(this,u)}assertValidity(){h(this)}hasEvenY(){let{y:u}=this.toAffine();if(t.isOdd)return!t.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){a(u);let{px:g,py:y,pz:v}=this,{px:O,py:N,pz:I}=u,b=t.eql(t.mul(g,I),t.mul(O,v)),A=t.eql(t.mul(y,I),t.mul(N,v));return b&&A}negate(){return new d(this.px,t.neg(this.py),this.pz)}double(){let{a:u,b:g}=n,y=t.mul(g,Se),{px:v,py:O,pz:N}=this,I=t.ZERO,b=t.ZERO,A=t.ZERO,B=t.mul(v,v),k=t.mul(O,O),U=t.mul(N,N),q=t.mul(v,O);return q=t.add(q,q),A=t.mul(v,N),A=t.add(A,A),I=t.mul(u,A),b=t.mul(y,U),b=t.add(I,b),I=t.sub(k,b),b=t.add(k,b),b=t.mul(I,b),I=t.mul(q,I),A=t.mul(y,A),U=t.mul(u,U),q=t.sub(B,U),q=t.mul(u,q),q=t.add(q,A),A=t.add(B,B),B=t.add(A,B),B=t.add(B,U),B=t.mul(B,q),b=t.add(b,B),U=t.mul(O,N),U=t.add(U,U),B=t.mul(U,q),I=t.sub(I,B),A=t.mul(U,k),A=t.add(A,A),A=t.add(A,A),new d(I,b,A)}add(u){a(u);let{px:g,py:y,pz:v}=this,{px:O,py:N,pz:I}=u,b=t.ZERO,A=t.ZERO,B=t.ZERO,k=n.a,U=t.mul(n.b,Se),q=t.mul(g,O),z=t.mul(y,N),l=t.mul(v,I),w=t.add(g,y),p=t.add(O,N);w=t.mul(w,p),p=t.add(q,z),w=t.sub(w,p),p=t.add(g,v);let S=t.add(O,I);return p=t.mul(p,S),S=t.add(q,l),p=t.sub(p,S),S=t.add(y,v),b=t.add(N,I),S=t.mul(S,b),b=t.add(z,l),S=t.sub(S,b),B=t.mul(k,p),b=t.mul(U,l),B=t.add(b,B),b=t.sub(z,B),B=t.add(z,B),A=t.mul(b,B),z=t.add(q,q),z=t.add(z,q),l=t.mul(k,l),p=t.mul(U,p),z=t.add(z,l),l=t.sub(q,l),l=t.mul(k,l),p=t.add(p,l),q=t.mul(z,p),A=t.add(A,q),q=t.mul(S,p),b=t.mul(w,b),b=t.sub(b,q),q=t.mul(w,z),B=t.mul(S,B),B=t.add(B,q),new d(b,A,B)}subtract(u){return this.add(u.negate())}is0(){return this.equals(d.ZERO)}wNAF(u){return L.wNAFCached(this,u,d.normalizeZ)}multiplyUnsafe(u){let{endo:g,n:y}=n;nt("scalar",u,Q,y);let v=d.ZERO;if(u===Q)return v;if(this.is0()||u===C)return this;if(!g||L.hasPrecomputes(this))return L.wNAFCachedUnsafe(this,u,d.normalizeZ);let{k1neg:O,k1:N,k2neg:I,k2:b}=g.splitScalar(u),A=v,B=v,k=this;for(;N>Q||b>Q;)N&C&&(A=A.add(k)),b&C&&(B=B.add(k)),k=k.double(),N>>=C,b>>=C;return O&&(A=A.negate()),I&&(B=B.negate()),B=new d(t.mul(B.px,g.beta),B.py,B.pz),A.add(B)}multiply(u){let{endo:g,n:y}=n;nt("scalar",u,C,y);let v,O;if(g){let{k1neg:N,k1:I,k2neg:b,k2:A}=g.splitScalar(u),{p:B,f:k}=this.wNAF(I),{p:U,f:q}=this.wNAF(A);B=L.constTimeNegate(N,B),U=L.constTimeNegate(b,U),U=new d(t.mul(U.px,g.beta),U.py,U.pz),v=B.add(U),O=k.add(q)}else{let{p:N,f:I}=this.wNAF(u);v=N,O=I}return d.normalizeZ([v,O])[0]}multiplyAndAddUnsafe(u,g,y){let v=d.BASE,O=(I,b)=>b===Q||b===C||!I.equals(v)?I.multiplyUnsafe(b):I.multiply(b),N=O(this,g).add(O(u,y));return N.is0()?void 0:N}toAffine(u){return E(this,u)}isTorsionFree(){let{h:u,isTorsionFree:g}=n;if(u===C)return!0;if(g)return g(d,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:u,clearCofactor:g}=n;return u===C?this:g?g(d,this):this.multiplyUnsafe(n.h)}toRawBytes(u=!0){return ct("isCompressed",u),this.assertValidity(),o(d,this,u)}toHex(u=!0){return ct("isCompressed",u),ft(this.toRawBytes(u))}}d.BASE=new d(n.Gx,n.Gy,t.ONE),d.ZERO=new d(t.ZERO,t.ONE,t.ZERO);let x=n.nBitLength,L=Ee(d,n.endo?Math.ceil(x/2):x);return{CURVE:n,ProjectivePoint:d,normPrivateKeyToScalar:s,weierstrassEquation:c,isWithinCurveOrder:f}}function on(e){let n=te(e);return rt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Ae(e){let n=on(e),{Fp:t,n:r}=n,o=t.BYTES+1,i=2*t.BYTES+1;function c(l){return D(l,r)}function f(l){return Ht(l,r)}let{ProjectivePoint:s,normPrivateKeyToScalar:a,weierstrassEquation:E,isWithinCurveOrder:h}=rn({...n,toBytes(l,w,p){let S=w.toAffine(),T=t.toBytes(S.x),H=yt;return ct("isCompressed",p),p?H(Uint8Array.from([w.hasEvenY()?2:3]),T):H(Uint8Array.from([4]),T,t.toBytes(S.y))},fromBytes(l){let w=l.length,p=l[0],S=l.subarray(1);if(w===o&&(p===2||p===3)){let T=P(S);if(!vt(T,C,t.ORDER))throw new Error("Point is not on curve");let H=E(T),Z;try{Z=t.sqrt(H)}catch(Y){let j=Y instanceof Error?": "+Y.message:"";throw new Error("Point is not on curve"+j)}let V=(Z&C)===C;return(p&1)===1!==V&&(Z=t.neg(Z)),{x:T,y:Z}}else if(w===i&&p===4){let T=t.fromBytes(S.subarray(0,t.BYTES)),H=t.fromBytes(S.subarray(t.BYTES,2*t.BYTES));return{x:T,y:H}}else{let T=o,H=i;throw new Error("invalid Point, expected length of "+T+", or uncompressed "+H+", got "+w)}}}),d=l=>ft(et(l,n.nByteLength));function x(l){let w=r>>C;return l>w}function L(l){return x(l)?c(-l):l}let m=(l,w,p)=>P(l.slice(w,p));class u{constructor(w,p,S){this.r=w,this.s=p,this.recovery=S,this.assertValidity()}static fromCompact(w){let p=n.nByteLength;return w=M("compactSignature",w,p*2),new u(m(w,0,p),m(w,p,2*p))}static fromDER(w){let{r:p,s:S}=X.toSig(M("DER",w));return new u(p,S)}assertValidity(){nt("r",this.r,C,r),nt("s",this.s,C,r)}addRecoveryBit(w){return new u(this.r,this.s,w)}recoverPublicKey(w){let{r:p,s:S,recovery:T}=this,H=I(M("msgHash",w));if(T==null||![0,1,2,3].includes(T))throw new Error("recovery id invalid");let Z=T===2||T===3?p+n.n:p;if(Z>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");let V=(T&1)===0?"02":"03",W=s.fromHex(V+d(Z)),Y=f(Z),j=c(-H*Y),dt=c(S*Y),J=s.BASE.multiplyAndAddUnsafe(W,j,dt);if(!J)throw new Error("point at infinify");return J.assertValidity(),J}hasHighS(){return x(this.s)}normalizeS(){return this.hasHighS()?new u(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return at(this.toDERHex())}toDERHex(){return X.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return at(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}let g={isValidPrivateKey(l){try{return a(l),!0}catch{return!1}},normPrivateKeyToScalar:a,randomPrivateKey:()=>{let l=Xt(n.n);return me(n.randomBytes(l),n.n)},precompute(l=8,w=s.BASE){return w._setWindowSize(l),w.multiply(BigInt(3)),w}};function y(l,w=!0){return s.fromPrivateKey(l).toRawBytes(w)}function v(l){let w=tt(l),p=typeof l=="string",S=(w||p)&&l.length;return w?S===o||S===i:p?S===2*o||S===2*i:l instanceof s}function O(l,w,p=!0){if(v(l))throw new Error("first arg must be private key");if(!v(w))throw new Error("second arg must be public key");return s.fromHex(w).multiply(a(l)).toRawBytes(p)}let N=n.bits2int||function(l){if(l.length>8192)throw new Error("input is too large");let w=P(l),p=l.length*8-n.nBitLength;return p>0?w>>BigInt(p):w},I=n.bits2int_modN||function(l){return c(N(l))},b=St(n.nBitLength);function A(l){return nt("num < 2^"+n.nBitLength,l,Q,b),et(l,n.nByteLength)}function B(l,w,p=k){if(["recovered","canonical"].some(ot=>ot in p))throw new Error("sign() legacy options not supported");let{hash:S,randomBytes:T}=n,{lowS:H,prehash:Z,extraEntropy:V}=p;H==null&&(H=!0),l=M("msgHash",l),ve(p),Z&&(l=M("prehashed msgHash",S(l)));let W=I(l),Y=a(w),j=[A(Y),A(W)];if(V!=null&&V!==!1){let ot=V===!0?T(t.BYTES):V;j.push(M("extraEntropy",ot))}let dt=yt(...j),J=W;function kt(ot){let ht=N(ot);if(!h(ht))return;let Vt=f(ht),bt=s.BASE.multiply(ht).toAffine(),it=c(bt.x);if(it===Q)return;let Et=c(Vt*c(J+it*Y));if(Et===Q)return;let gt=(bt.x===it?0:2)|Number(bt.y&C),ne=Et;return H&&x(Et)&&(ne=L(Et),gt^=1),new u(it,ne,gt)}return{seed:dt,k2sig:kt}}let k={lowS:n.lowS,prehash:!1},U={lowS:n.lowS,prehash:!1};function q(l,w,p=k){let{seed:S,k2sig:T}=B(l,w,p),H=n;return Kt(H.hash.outputLen,H.nByteLength,H.hmac)(S,T)}s.BASE._setWindowSize(8);function z(l,w,p,S=U){let T=l;w=M("msgHash",w),p=M("publicKey",p);let{lowS:H,prehash:Z,format:V}=S;if(ve(S),"strict"in S)throw new Error("options.strict was renamed to lowS");if(V!==void 0&&V!=="compact"&&V!=="der")throw new Error("format must be compact or der");let W=typeof T=="string"||tt(T),Y=!W&&!V&&typeof T=="object"&&T!==null&&typeof T.r=="bigint"&&typeof T.s=="bigint";if(!W&&!Y)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let j,dt;try{if(Y&&(j=new u(T.r,T.s)),W){try{V!=="compact"&&(j=u.fromDER(T))}catch(gt){if(!(gt instanceof X.Err))throw gt}!j&&V!=="der"&&(j=u.fromCompact(T))}dt=s.fromHex(p)}catch{return!1}if(!j||H&&j.hasHighS())return!1;Z&&(w=n.hash(w));let{r:J,s:kt}=j,ot=I(w),ht=f(kt),Vt=c(ot*ht),bt=c(J*ht),it=s.BASE.multiplyAndAddUnsafe(dt,Vt,bt)?.toAffine();return it?c(it.x)===J:!1}return{CURVE:n,getPublicKey:y,getSharedSecret:O,sign:q,verify:z,ProjectivePoint:s,Signature:u,utils:g}}function sn(e){return{hash:e,hmac:(n,...t)=>jt(e,n,se(...t)),randomBytes:fe}}function Oe(e,n){let t=r=>Ae({...e,...sn(r)});return{...t(n),create:t}}var Ie=_t(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),cn=Ie.create(BigInt("-3")),fn=BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),un=Oe({a:cn,b:fn,Fp:Ie,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},le);export{un as p256,Rt as utils};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/p256.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
